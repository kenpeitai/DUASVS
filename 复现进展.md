# DUASVS 复现进展（截至当前仓库状态）

本文档用于记录 **DUASVS（Decoupled User–Action Space for short-video streaming, OOD 泛化）** 在本仓库的复现进展：包含论文方法要点、我们落地的环境语义、状态/动作/奖励设计、论文数据集 vs 本仓库数据集映射、以及当前训练/评估参数与已跑结果。

---

## 1. 论文方法（DUASVS）简述

DUASVS 的核心目标是：在 **用户行为分布固定** 的前提下，将 **网络分布变化** 作为 OOD（Out-of-Distribution）来源，研究短视频流式决策模型在跨域网络条件下的泛化能力。

关键建模要点：
- **解耦数据**：用户行为（短视频观看/滑动）来自真实推荐/观看数据集；网络动态来自真实移动/宽带 traces。
- **per-video 决策**：智能体每个视频只做一次决策（不是 chunk-level ABR）。
- **联合动作空间**：同时控制 **码率** 与 **预取深度**（prefetch threshold），在“卡顿 vs 浪费”的权衡中学习策略。
- **OOD 测评协议**：训练/验证在 In-D 网络域（如 FCC），测试在 OOD 网络域（如 MONROE），不允许 finetune。

---

## 2. 本仓库实现的环境语义（当前版本）

环境实现文件：`envs/duasvs_env.py`

### 2.1 网络 trace 使用方式
- 每次 `reset()` 选定 **一条 trace**（FCC/MONROE），该 trace 的时间索引 `t` 在 episode 内 **按 1s 推进**，并且 **跨视频不重置**（同一条 trace 会连续服务多个视频）。
- trace 数据列：`trace_id,t,throughput_kbps`，在 env 内换算为 `Mbps`。

### 2.2 预取（prefetch_threshold）语义
我们按论文语义实现为 **“ahead-of-playback 未播放缓冲上限（秒）”**，并在本仓库落地为：
- **跨视频预取**：当前视频下载完后，可继续按 **当前决策的码率（方案 A）** 预取后续视频，直到达到 `prefetch_threshold`。
- **阈值严格不超调**：单个 1s slot 内下载的内容会被截断，确保 `buffer_ahead ≤ prefetch_threshold`。
- **优先保障当前视频**：避免“未来预取占满阈值导致当前视频不下载”的死锁；实现为“先填当前视频 buffer 到阈值（且未下完），再考虑预取未来”。

### 2.3 outage 与数值保护
为保留原始吞吐序列并处理断连：
- `thr_outage_mbps = 0.02`：吞吐小于该阈值视为 outage，该秒下载增量为 0。
- `eps_mbps = 0.01`：用于除法/对数的数值保护。

### 2.4 用户耐心（短视频 realism）
为避免“无限等待导致 rebuffer 无上限”的不稳定训练/评估：
- `max_rebuf_s_per_video = 8.0s`：单视频累计卡顿达到上限后，用户视为 **划走**（停止等待继续播放该视频）。
- 目前 **无显式 swipe 额外惩罚项**，划走只通过 `rebuf`、观看比例缩放、以及 `waste` 间接影响 reward。

---

## 3. 状态空间 / 动作空间 / 奖励（当前版本）

### 3.1 状态（State）
每一步（一个视频）观测包含：
- **最近 K 秒吞吐历史**（归一化/截断）
- **session buffer 占用**（秒，归一化）
- **当前视频在各码率档位下的 size 向量**（H 维；按 CBR 近似 \(size_h = bitrate_h \times L_i\)，并归一化）
- **当前视频长度**（秒，归一化）
- **上一条视频码率索引**（按码率档位数归一化）

K 默认 `k_hist=8`。

### 3.2 动作（Action）
联合动作：`(bitrate_idx, prefetch_threshold_idx)`，离散编码为一个整数：
- **码率档位（4）**：`[360p, 480p, 720p, 1080p]`
  - `video_bitrates_mbps = [0.7, 1.2, 2.5, 5.0]`
- **prefetch_threshold（7）**：`[1, 2, 4, 6, 8, 12, 18]` 秒

总动作数：`4 * 7 = 28`。

### 3.3 奖励（Reward）
每个视频一步的 reward：
- QoE（Pensieve 风格）：
  - 码率收益：`log(bitrate/r_min)`，并乘以 **实际观看比例** `played_s / watch_s`
  - 切换惩罚：`switch_penalty * |log(b_t/r_min) - log(b_{t-1}/r_min)|`
  - 卡顿惩罚：`rebuf_penalty * rebuf_s`
- 浪费惩罚：按 **数据量**（Mbit）惩罚：
  - `waste_mbit = bitrate_mbps * waste_s`（并包含“丢弃的预取”）
  - `reward = QoE - lambda_waste * waste_mbit`

关键系数默认值（可在 env config 中覆盖）：
- `r_min_mbps = 0.2`
- `rebuf_penalty = 2.66`
- `switch_penalty = 1.0`
- `lambda_waste = 0.5`（单位：reward/Mbit）

---

## 4. 论文数据集 vs 本仓库数据集映射

### 4.1 论文使用（概念层）
- **用户行为**：短视频真实观看/滑动序列（例如 KuaiRec/类似短视频数据）。
- **网络域 In-D（训练/验证）**：FCC / M-Lab 等真实网络 traces。
- **网络域 OOD（测试）**：MONROE 等移动网络 traces。

### 4.2 本仓库落地（文件层）
- **用户行为（KuaiRec）**：
  - `data/big_matrix_valid_video.csv`
  - 主要字段：`user_id, video_id, play_duration, video_duration, timestamp, ...`
- **网络 traces（In-D：FCC）**：
  - `data/fcc_httpgetmt_trace_1s_kbps.csv`
  - 划分：`splits/fcc_train_trace_ids.txt` / `splits/fcc_val_trace_ids.txt` / `splits/fcc_test_trace_ids.txt`（如有）
- **网络 traces（OOD：MONROE）**：
  - `data/monroe_*.csv`（例如 `monroe_sweden.csv`, `monroe_spain.csv`, `monroe_italy.csv`, `monroe_norway.csv`）
- **可选行为抽样（全局统计）**：
  - `data/video_index.csv`（用于 `behavior_mode=video_index`，可降低用户差异噪声；当前官方跑主要用 `user_sessions`）

---

## 5. 训练与评估脚本（当前）

### 5.1 训练脚本
- `train_duasvs_ppo.py`（PPO）
- 支持：`--device cuda/cpu`、`--converge_check`、`--resume`、保存 `*_best.pt` / `*_latest.pt`
- 评估（In-D）默认：每 `4096` environment steps（一个 update）评估一次。

### 5.2 OOD 评估脚本
- `evaluate_duasvs.py`
- 支持多域评估（FCC + MONROE），输出 episodes 与 summary。

---

## 6. 当前参数设定（official runs）

### 6.1 official 训练（In-D：FCC）
（以 seed0/seed6 为例）
- `mode=official`
- `total_steps=300000`
- `device=cuda`
- `eval_every_updates=1`（每 4096 步一次）
- `eval_n_traces=50`
- `eval_max_videos=1000`

### 6.2 固定大样本评估（用于收敛判定）
为了判断“是不是小样本偶然 best”，我们增加了固定评估口径：
- **FCC-val**：抽 200 条 trace（固定随机种子），每条最多 2000 videos，固定 `session_seed`。

---

## 7. 已跑结果与产物（文件路径）

### 7.1 seed0 official（300k）
- 训练输出（eval/loss）：`checkpoints/official_seed0_patience_wastembit_steps300k_*.csv`
- best/latest ckpt：
  - `checkpoints/official_seed0_patience_wastembit_steps300k_best.pt`
  - `checkpoints/official_seed0_patience_wastembit_steps300k_latest.pt`
- 画图：
  - `checkpoints/plots/official_seed0_patience_wastembit_steps300k_eval.png` / `.svg`
  - `checkpoints/plots/official_seed0_patience_wastembit_steps300k_loss.png` / `.svg`
- 大样本固定评估（best vs latest）：
  - `checkpoints/official_seed0_patience_wastembit_steps300k_fixed_fccval200x2000_best_vs_latest.csv`

### 7.2 seed6 official（300k）
- 训练输出（eval/loss）：`checkpoints/official_seed6_patience_wastembit_steps300k_*.csv`
- best/latest ckpt：
  - `checkpoints/official_seed6_patience_wastembit_steps300k_best.pt`
  - `checkpoints/official_seed6_patience_wastembit_steps300k_latest.pt`
- 画图：
  - `checkpoints/plots/official_seed6_patience_wastembit_steps300k_eval.png` / `.svg`
  - `checkpoints/plots/official_seed6_patience_wastembit_steps300k_loss.png` / `.svg`
- 大样本固定评估（best vs latest）：
  - `checkpoints/official_seed6_patience_wastembit_steps300k_fixed_fccval200x2000_best_vs_latest.csv`

---

## 8. 与论文可能存在的差异（需在写论文/报告时明确）

为提升仿真稳定性与短视频合理性，我们引入了若干“现实化”假设，和论文原文可能存在差异（论文未明确的部分我们做了可复现落地）：
- **用户耐心上限**（避免无限等待导致的无界 rebuffer）。
- **码率收益按观看比例缩放**（更贴近短视频刷视频的收益/体验）。
- **浪费按数据量（Mbit）惩罚**（更符合“省流量”的实际成本）。
- **跨视频预取的具体实现细节**（论文对“跨视频预取多久/如何计入”未完全写死，本仓库采用“方案 A：用当前决策码率预取后续”）。

如果需要对齐论文的严格定义，我们可以继续把这些差异做成可开关参数，并在复现实验里分别对照。


